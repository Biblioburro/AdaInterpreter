package Compiler;
import java.util.ArrayList;
public class adaScanner {
	//constructors
public adaScanner() {
	
}
public adaScanner(String contents) {
	rawData = contents.toLowerCase();
	processString();
}

//process the String stored into raw data for the scanner
public void processString( ) {
	//store the current lexeme
	String currLex = "";
	//go through the provided string one character
	//at a time
	for(int i =0 ; i< rawData.length();i++) {
		if(rawData.charAt(i)== ' ' || rawData.charAt(0) == '.') {
			
			identifyToken(currLex);
			currLex = "";
		}else {
			currLex += rawData.charAt(i);
		}
		
		
	}
	
	
}
//functions to process the lexemes generated by the processString function
public void tokenize() {
	
}
//function to search the token table and identify which token
//it corresponds to
public void identifyToken(String lex) {
	System.out.print(++numLex);
}
//
public void setContents() {
	
}
// declare and intialize variables
static int numLex = 0;
private String rawData;
private ArrayList<String> lexemes;
private ArrayList<String> tokens;
//Entire list of ada keywords and operator.
private String[][] tokenTable = {{";","End of Line"},{"with","with keyword"},{"use","use keyword"},{"begin","begin keyword"},
								{"body","case"},{"case","case identifier"},{"cosntant","constant identifier"},
								{"declare","declare keyword"},{"digits","digits identifier"},{"do", "do identifier"},
								{"else","else identifier"},{"elsif","else if identifier"},{"end","end identfier"},
								{"exception","exception identifier"},{"exit","exit identifier"},{"for","for identifier"},
								{"function","function identifier"},{"generic","generic identifier"},{"goto","goto identifier"},
								{"if","if identifier"},{"in","in identifier"},{"interface","interface identifier"},
								{"is","is identifier"},{"limited","limited keyword"},{"loop","loop identifier"},
								{"mod","modulus operator"},{"new","new identfier"},{"not","logical operator"},
								{"null","null identifier"},{"of","of identifier"},{"or","logical operator"},
								{"others","others identfier"},{"out","out identifier"},{"overriding","overriding identifier"},
								{"package","package identifier"},{"pragma","pragma identifier"},{"private","private identifier"},
								{"procedure","procedure identifier"},{"protected","protected identifier"},
								{"raise","raise identifier"},{"range","range identifier"},
								{"record","record identfier"},{"rem","remainder operator"},
								{"renames","renames identifier"},{"requeue","requeue identifier"},
								{"return","return identifier"},{"reverse","reverse identifier"},
								{"reverse","reverse identifier"},{"select","select operator"},
								{"seperate","seperate identifier"},{"some","some identifier"},
								{"subtype","subtype identifier"},{"synchronized","synchronized identifier"},
								{"tagged","tagged identifier"},{"task","task identifier"},
								{"terminate","terminate identifier"},{"then","then identifier"},
								{"type","type identifier"},{"until","until identifier"},
								{"use","use identifier"},{"when","when identifier"},
								{"while","while identifier"},{"with","with identifier"},
								{"xor","logical operator"},{"+","addition operator"},
								{"-","subtraction operator"},{"*","multiplication operator"},
								{"/","division operator"},{":=","assignment operator"},
								{"and","logical operator"},{"array","array keyword"},{"at","at keyword"}}; 


}
